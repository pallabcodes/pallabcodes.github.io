<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>Pallab Codes</title>
      <link>https://pallabcodes.github.io</link>
      <description>Software Engineering Blog - Deep dives into systems, architecture, and code</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://pallabcodes.github.io/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Fri, 19 Dec 2025 00:00:00 +0000</lastBuildDate>
      <item>
          <title>The Go Scheduler: G-P-M Model Explained</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-scheduler-explained/</link>
          <guid>https://pallabcodes.github.io/go-scheduler-explained/</guid>
          <description xml:base="https://pallabcodes.github.io/go-scheduler-explained/">&lt;p&gt;Go runs many goroutines on few OS threads. Understanding how is the difference between hoping your concurrent code works and &lt;em&gt;knowing&lt;&#x2F;em&gt; it works.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>The Go Scheduler Part 2: Leaks, Supervision &amp; Backpressure</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-scheduler-part-2/</link>
          <guid>https://pallabcodes.github.io/go-scheduler-part-2/</guid>
          <description xml:base="https://pallabcodes.github.io/go-scheduler-part-2/">&lt;p&gt;Part 1 explained the G-P-M model. This part covers what happens when things go wrong: real leak postmortems, proper supervision, backpressure design, and how Go compares to Rust&#x27;s async model.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Go Templates Part 1: The Mental Model</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-templates-part-1/</link>
          <guid>https://pallabcodes.github.io/go-templates-part-1/</guid>
          <description xml:base="https://pallabcodes.github.io/go-templates-part-1/">&lt;p&gt;Go&#x27;s &lt;code&gt;text&#x2F;template&lt;&#x2F;code&gt; package looks simple until you actually use it. Then you hit the dot, get confused by context, and wonder why your template panics on nil. This post builds the mental model you need.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Go Templates Part 2: Patterns That Scale</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-templates-part-2/</link>
          <guid>https://pallabcodes.github.io/go-templates-part-2/</guid>
          <description xml:base="https://pallabcodes.github.io/go-templates-part-2/">&lt;p&gt;Part 1 covered the mental model. Now let&#x27;s look at the patterns you&#x27;ll actually use in production: context control, iteration, functions, and composition.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Go Templates Part 3: Production Hardening</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-templates-part-3/</link>
          <guid>https://pallabcodes.github.io/go-templates-part-3/</guid>
          <description xml:base="https://pallabcodes.github.io/go-templates-part-3/">&lt;p&gt;Templates look harmless until they start panicking in production at 3 AM. This post covers the real-world concerns: debugging execution errors, caching safely, avoiding security mistakes, and keeping things fast.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Go Templates Part 4: Operating Templates at Scale</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-templates-part-4/</link>
          <guid>https://pallabcodes.github.io/go-templates-part-4/</guid>
          <description xml:base="https://pallabcodes.github.io/go-templates-part-4/">&lt;p&gt;At a certain scale, templates become infrastructure. They need versioning, observability, rollback, and operational runbooks. This post covers how to treat templates as first-class production assets.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Production Concurrency: Backpressure, Pipelines &amp; Real Failures</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/production-concurrency-pipelines/</link>
          <guid>https://pallabcodes.github.io/production-concurrency-pipelines/</guid>
          <description xml:base="https://pallabcodes.github.io/production-concurrency-pipelines/">&lt;p&gt;This post goes beyond patterns into production system design: how backpressure actually works, why Go and Rust handle cancellation differently, and a complete walkthrough of designing a distributed pipeline that won&#x27;t fail at 3am.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Share Memory by Communicating Part 1: The Pattern</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/share-memory-communicating-part-1/</link>
          <guid>https://pallabcodes.github.io/share-memory-communicating-part-1/</guid>
          <description xml:base="https://pallabcodes.github.io/share-memory-communicating-part-1/">&lt;p&gt;Go&#x27;s famous proverb—&quot;Don&#x27;t communicate by sharing memory; share memory by communicating&quot;—sounds abstract until you see it in action. This post breaks down the pattern, why it exists, and when to use it.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Share Memory by Communicating Part 2: Lifecycle &amp; Failure</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/share-memory-communicating-part-2/</link>
          <guid>https://pallabcodes.github.io/share-memory-communicating-part-2/</guid>
          <description xml:base="https://pallabcodes.github.io/share-memory-communicating-part-2/">&lt;p&gt;Part 1 showed the pattern. This part explains why it breaks in production without proper lifecycle management—and how goroutine leaks silently kill systems.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Share Memory by Communicating Part 3: Context &amp; Supervision</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/share-memory-communicating-part-3/</link>
          <guid>https://pallabcodes.github.io/share-memory-communicating-part-3/</guid>
          <description xml:base="https://pallabcodes.github.io/share-memory-communicating-part-3/">&lt;p&gt;Part 2 explained why the naive pattern breaks. This part fixes it with proper context-based cancellation and supervision.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Share Memory by Communicating Part 4: Scaling &amp; Production Patterns</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/share-memory-communicating-part-4/</link>
          <guid>https://pallabcodes.github.io/share-memory-communicating-part-4/</guid>
          <description xml:base="https://pallabcodes.github.io/share-memory-communicating-part-4/">&lt;p&gt;Parts 1-3 built the foundation. This final part covers production scaling: buffered channels, Kubernetes integration, errgroup supervision, performance tuning, and comparisons with Erlang&#x2F;Akka.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Handling OS Signals in Go</title>
          <pubDate>Thu, 18 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-signals/</link>
          <guid>https://pallabcodes.github.io/go-signals/</guid>
          <description xml:base="https://pallabcodes.github.io/go-signals/">&lt;p&gt;Every long-running Go program—whether it&#x27;s an HTTP server, a worker process, or a CLI tool—needs to handle shutdown gracefully. You don&#x27;t want your database connections left hanging or your in-flight requests aborted mid-write when someone hits Ctrl+C.&lt;&#x2F;p&gt;
&lt;p&gt;Go makes this surprisingly elegant by treating OS signals as just another event source you can receive on a channel. Let&#x27;s dig into how it actually works.&lt;&#x2F;p&gt;</description>
      </item>
    </channel>
</rss>
