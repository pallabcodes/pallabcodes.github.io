<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>Pallab Codes</title>
      <link>https://pallabcodes.github.io</link>
      <description>Software Engineering Blog - Deep dives into systems, architecture, and code</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://pallabcodes.github.io/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Sat, 20 Dec 2025 00:00:00 +0000</lastBuildDate>
      <item>
          <title>Go Worker Pools: Channels as Synchronization</title>
          <pubDate>Sat, 20 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-worker-pools/</link>
          <guid>https://pallabcodes.github.io/go-worker-pools/</guid>
          <description xml:base="https://pallabcodes.github.io/go-worker-pools/">&lt;p&gt;The worker pool is Go&#x27;s workhorse pattern. What makes Go&#x27;s version unique is how channels serve as &lt;em&gt;both&lt;&#x2F;em&gt; the data pipeline &lt;em&gt;and&lt;&#x2F;em&gt; the synchronization mechanism. This post dissects the mechanics.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Scaling Go Actors: Sharding State Owners</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-actors-sharding/</link>
          <guid>https://pallabcodes.github.io/go-actors-sharding/</guid>
          <description xml:base="https://pallabcodes.github.io/go-actors-sharding/">&lt;p&gt;The actor pattern serializes access to state through a single goroutine. This guarantees correctness but creates a throughput ceiling. When that becomes your bottleneck, the answer is sharding.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Go Channels: The Request-Response Pattern Demystified</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-channels-request-response/</link>
          <guid>https://pallabcodes.github.io/go-channels-request-response/</guid>
          <description xml:base="https://pallabcodes.github.io/go-channels-request-response/">&lt;p&gt;This post explains the mechanics that confuse even experienced engineers: why sender&#x2F;receiver roles flip per channel, how request-response actually works, and why the response field must be a channel.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Go Closures and Goroutines: The Capture Bug</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-closures-goroutines/</link>
          <guid>https://pallabcodes.github.io/go-closures-goroutines/</guid>
          <description xml:base="https://pallabcodes.github.io/go-closures-goroutines/">&lt;p&gt;Every Go developer hits this bug at least once. Understanding why it happens requires understanding how closures work. This post explains the mechanics precisely.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>The Go Concurrency Toolbox: When to Use What</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-concurrency-toolbox/</link>
          <guid>https://pallabcodes.github.io/go-concurrency-toolbox/</guid>
          <description xml:base="https://pallabcodes.github.io/go-concurrency-toolbox/">&lt;p&gt;Go gives you multiple concurrency primitives. Each exists for a reason. This post provides a decision framework for choosing the right one—not by feature comparison, but by workload analysis.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>The Mechanics of Go Execution: A Timeline View</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-execution-mechanics/</link>
          <guid>https://pallabcodes.github.io/go-execution-mechanics/</guid>
          <description xml:base="https://pallabcodes.github.io/go-execution-mechanics/">&lt;p&gt;One of the hardest mental shifts in Go is understanding that &lt;code&gt;go func()&lt;&#x2F;code&gt; arranges for code to run &lt;em&gt;later&lt;&#x2F;em&gt;, not &lt;em&gt;now&lt;&#x2F;em&gt;. This post breaks down the execution timeline of a concurrent loop to kill the &quot;sequential intuition&quot; once and for all.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Go Mutex vs WaitGroup: Safety, Coordination, and Ordering</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-mutex-waitgroup-ordering/</link>
          <guid>https://pallabcodes.github.io/go-mutex-waitgroup-ordering/</guid>
          <description xml:base="https://pallabcodes.github.io/go-mutex-waitgroup-ordering/">&lt;p&gt;We often confuse &quot;safety&quot; with &quot;ordering&quot;. This post dissects the mechanical difference between &lt;code&gt;sync.Mutex&lt;&#x2F;code&gt; (safety) and &lt;code&gt;sync.WaitGroup&lt;&#x2F;code&gt; (coordination), and why a race-free program can still be nondeterministic.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>The Go Scheduler: G-P-M Model Explained</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-scheduler-explained/</link>
          <guid>https://pallabcodes.github.io/go-scheduler-explained/</guid>
          <description xml:base="https://pallabcodes.github.io/go-scheduler-explained/">&lt;p&gt;Go runs many goroutines on few OS threads. Understanding how is the difference between hoping your concurrent code works and &lt;em&gt;knowing&lt;&#x2F;em&gt; it works.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>The Go Scheduler Part 2: Leaks, Supervision &amp; Backpressure</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-scheduler-part-2/</link>
          <guid>https://pallabcodes.github.io/go-scheduler-part-2/</guid>
          <description xml:base="https://pallabcodes.github.io/go-scheduler-part-2/">&lt;p&gt;Part 1 explained the G-P-M model. This part covers what happens when things go wrong: real leak postmortems, proper supervision, backpressure design, and how Go compares to Rust&#x27;s async model.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Go Templates Part 1: The Mental Model</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-templates-part-1/</link>
          <guid>https://pallabcodes.github.io/go-templates-part-1/</guid>
          <description xml:base="https://pallabcodes.github.io/go-templates-part-1/">&lt;p&gt;Go&#x27;s &lt;code&gt;text&#x2F;template&lt;&#x2F;code&gt; package looks simple until you actually use it. Then you hit the dot, get confused by context, and wonder why your template panics on nil. This post builds the mental model you need.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Go Templates Part 2: Patterns That Scale</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-templates-part-2/</link>
          <guid>https://pallabcodes.github.io/go-templates-part-2/</guid>
          <description xml:base="https://pallabcodes.github.io/go-templates-part-2/">&lt;p&gt;Part 1 covered the mental model. Now let&#x27;s look at the patterns you&#x27;ll actually use in production: context control, iteration, functions, and composition.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Go Templates Part 3: Production Hardening</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-templates-part-3/</link>
          <guid>https://pallabcodes.github.io/go-templates-part-3/</guid>
          <description xml:base="https://pallabcodes.github.io/go-templates-part-3/">&lt;p&gt;Templates look harmless until they start panicking in production at 3 AM. This post covers the real-world concerns: debugging execution errors, caching safely, avoiding security mistakes, and keeping things fast.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Go Templates Part 4: Operating Templates at Scale</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-templates-part-4/</link>
          <guid>https://pallabcodes.github.io/go-templates-part-4/</guid>
          <description xml:base="https://pallabcodes.github.io/go-templates-part-4/">&lt;p&gt;At a certain scale, templates become infrastructure. They need versioning, observability, rollback, and operational runbooks. This post covers how to treat templates as first-class production assets.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Production Concurrency: Backpressure, Pipelines &amp; Real Failures</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/production-concurrency-pipelines/</link>
          <guid>https://pallabcodes.github.io/production-concurrency-pipelines/</guid>
          <description xml:base="https://pallabcodes.github.io/production-concurrency-pipelines/">&lt;p&gt;This post goes beyond patterns into production system design: how backpressure actually works, why Go and Rust handle cancellation differently, and a complete walkthrough of designing a distributed pipeline that won&#x27;t fail at 3am.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Share Memory by Communicating Part 1: The Pattern</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/share-memory-communicating-part-1/</link>
          <guid>https://pallabcodes.github.io/share-memory-communicating-part-1/</guid>
          <description xml:base="https://pallabcodes.github.io/share-memory-communicating-part-1/">&lt;p&gt;Go&#x27;s famous proverb—&quot;Don&#x27;t communicate by sharing memory; share memory by communicating&quot;—sounds abstract until you see it in action. This post breaks down the pattern, why it exists, and when to use it.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Share Memory by Communicating Part 2: Lifecycle &amp; Failure</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/share-memory-communicating-part-2/</link>
          <guid>https://pallabcodes.github.io/share-memory-communicating-part-2/</guid>
          <description xml:base="https://pallabcodes.github.io/share-memory-communicating-part-2/">&lt;p&gt;Part 1 showed the pattern. This part explains why it breaks in production without proper lifecycle management—and how goroutine leaks silently kill systems.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Share Memory by Communicating Part 3: Context &amp; Supervision</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/share-memory-communicating-part-3/</link>
          <guid>https://pallabcodes.github.io/share-memory-communicating-part-3/</guid>
          <description xml:base="https://pallabcodes.github.io/share-memory-communicating-part-3/">&lt;p&gt;Part 2 explained why the naive pattern breaks. This part fixes it with proper context-based cancellation and supervision.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Share Memory by Communicating Part 4: Scaling &amp; Production Patterns</title>
          <pubDate>Fri, 19 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/share-memory-communicating-part-4/</link>
          <guid>https://pallabcodes.github.io/share-memory-communicating-part-4/</guid>
          <description xml:base="https://pallabcodes.github.io/share-memory-communicating-part-4/">&lt;p&gt;Parts 1-3 built the foundation. This final part covers production scaling: buffered channels, Kubernetes integration, errgroup supervision, performance tuning, and comparisons with Erlang&#x2F;Akka.&lt;&#x2F;p&gt;</description>
      </item>
      <item>
          <title>Handling OS Signals in Go</title>
          <pubDate>Thu, 18 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://pallabcodes.github.io/go-signals/</link>
          <guid>https://pallabcodes.github.io/go-signals/</guid>
          <description xml:base="https://pallabcodes.github.io/go-signals/">&lt;p&gt;Every long-running Go program—whether it&#x27;s an HTTP server, a worker process, or a CLI tool—needs to handle shutdown gracefully. You don&#x27;t want your database connections left hanging or your in-flight requests aborted mid-write when someone hits Ctrl+C.&lt;&#x2F;p&gt;
&lt;p&gt;Go makes this surprisingly elegant by treating OS signals as just another event source you can receive on a channel. Let&#x27;s dig into how it actually works.&lt;&#x2F;p&gt;</description>
      </item>
    </channel>
</rss>
